subroutine cal_error(nx0, ny0, np, nb, r0, degree)
    use mod_reynolds, only: nr
    use mod_sympoly, only: maxv, mons, monid
    use mod_genpoly, only: norder, btotal
    use mod_fi, only: nfi, fmons, fmonid, nexit
    implicit none
    integer, intent(in) :: np, nb, nx0, ny0, degree
    real(kind=8), intent(in) :: r0(nr, maxv)
    integer :: nx, ny ! number of data randomly generated
    integer :: i, j, k, iloop, nfi0, i0
    real(kind=8) :: matA(nx0, ny0), vecB(nx0), coefC(nx0), matAx(nx0, ny0), vecBx(nx0)
    real(kind=8) :: v, error, work(2*nx0*ny0)
! matA(nx0,ny0) nx0 is the maximal dimension of samples
! matA(nx0,ny0) ny0 is the maximal number of polynomials which contain
! the polynomials generated by degree 1 ~ N-1, and the new FIs.
! calculate nb samples for the nfi FIs.
! matA(1:nb,1:nfi)
    nfi0 = nfi
    nx = nb + 100
    ny = nb
    do i = 1, nx
        do j = 1, nfi0
            k = fmonid(j) - 1
            call poly_value(fmonid(j), fmons(1, 1:k, j), fmons(2, 1:k, j), r0(1:nr, i), matA(i, j))
        end do
    end do
! add the value of polynomials generated by
! the previous FIs
! matA(1:nb,nfi+1,nfi+nb)
    do i = 1, nb
        matA(1:nx, nfi0 + i) = 1.d0
        do j = 1, btotal(0, i)
            matA(1:nx, nfi0 + i) = matA(1:nx, nfi0 + i)*matA(1:nx, btotal(j, i))
        end do
    end do
! test whether the new polynomials in degree N is a FI,
! if it is a FI, add it to matA
    do iloop = 1, np
        do i = 1, nx
            k = monid(iloop) - 1
            call poly_value(monid(iloop), mons(1, 1:k, iloop), mons(2, 1:k, iloop), r0(1:nr, i), vecB(i))
        end do
        matAx(1:nx, 1:ny) = matA(1:nx, nfi0 + 1:nfi0 + ny)
        vecBx(1:nx) = vecB(1:nx)
        call lsq(nx, ny, nx0, ny0, matAx, vecBx, coefC, work)
        error = 0.d0
        do i = 1, nx
            v = 0.d0
            do j = 1, ny
                v = v + coefC(j)*matA(i, nfi0 + j)
            end do
            error = error + ((v - vecB(i)))**2
        end do
        error = (error/real(nx))**(1.d0/2.d0)
        if (error .gt. 1.d0) then
            nfi = nfi + 1
            fmons(:, :, nfi) = mons(:, :, iloop)
            fmonid(nfi) = monid(iloop)
            norder(degree) = norder(degree) + 1
            call write_poly(fmonid(nfi), fmons(1, 1:fmonid(nfi) - 1, nfi), fmons(2, 1:fmonid(nfi) - 1, nfi), nfi)
            !-------------------
            ny = ny + 1
            matA(1:nx, nfi0 + ny) = vecB(1:nx)
            do i0 = 1, 1
                nx = nx + 1
                do j = 1, nfi0
                    k = fmonid(j) - 1
                    call poly_value(fmonid(j), fmons(1, 1:k, j), fmons(2, 1:k, j), r0(1:nr, nx), matA(nx, j))
                end do
                do i = 1, nb
                    matA(nx, nfi0 + i) = 1.d0
                    do j = 1, btotal(0, i)
                        matA(nx, nfi0 + i) = matA(nx, nfi0 + i)*matA(nx, btotal(j, i))
                    end do
                end do
                do i = 1, nfi - nfi0
                    k = fmonid(nfi0 + i) - 1
                    j = nfi0 + nb + i
                    call poly_value(fmonid(nfi0 + i), fmons(1, 1:k, nfi0 + i), fmons(2, 1:k, nfi0 + i), r0(1:nr, nx), matA(nx, j))
                end do
            end do
          write (702, '(i3,"*  ",i5,",",i5," in degree ",(i2),",",2x,3(1x,i6),2xes23.16)') nfi, iloop, np, degree, nb, nx, ny, error
            i0 = 1
            do i = 1, nexit(0)
                if (nfi .eq. nexit(i)) then
                    i0 = 0
                    exit
                end if
            end do
            if (i0 .eq. 0) exit
            !-------------------
            !do j=1,ny
            !  write(711,*) j,coefC(j)
            !enddo
            !  write(711,*) ""
            ! else
            !do j=1,ny
            !  write(713,*) j,coefC(j)
            !enddo
            !  write(713,*) ""
        else
            write (702, '(6x,i5,",",i5," in degree ",(i2),","2x,3(1x,i6),2xes23.16)') iloop, np, degree, nb, nx, ny, error
        end if
    end do
end subroutine cal_error

subroutine lsq(m, n, m0, n0, A, B, C, work)
    implicit none
    integer, intent(in) :: m, n, m0, n0
    real(kind=8), intent(in) :: A(m0, n0), B(m0)
    real(kind=8), intent(out) :: C(m0)
    real(kind=8), intent(inout) :: work(2*m0*n0)
    integer :: info, lwork
!call dgels('N',m,n,1,A,m0,B,m0,work,-1,info)
!lwork=int(work(1))
    lwork = 2*m*n
    call dgels('N', m, n, 1, A, m0, B, m0, work, lwork, info)
    C(1:n) = B(1:n)
end subroutine lsq
